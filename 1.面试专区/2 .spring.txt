一、谈谈Srping IOC的理解、原理与实现
总：
1、控制反转：原来的对象是由使用者控制的，有了Spring之后，可以把整个对象交给Spring来帮助我们进行管理
   依赖注入（DI）：把对应的属性的值注入到具体的对象中，@Autowired完成属性值的注入
2、容器：存储对象，使用map结构来存储，在spring中一般存在三级缓存，singletonObject存放完整的object对象。整个bean的生命周期，从创建到销毁的过程都是由容器来管理的
分：
1、一般聊IOC容器的时候涉及到容器的创建过程（重要：beanFactory，DefaultListableBeanFactory），向bean工厂中设置一些参数（BeanPostProcessor，Aware接口的子类）等等属性
2、加载解析bean对象，准备要创建的bean对象的定义对象BeanDefinition（XML或注解的解析过程）
3、BeanFactoryPostProcessor的处理，此处是扩展点，PlaceHolderConfigSupport，ConfigurationClassProcessor
4、BeanPostProcessor的注册功能，方便后续对bean对象完成具体的扩展功能
5、通过反射的方式将BeanDefinition对象实例化成具体的bean对象
6、bean对象的初始化过程（填充属性，调用aware子类的方法，调用BeanPostProcessor前置处理方法，调用init-method方法，调用BeanPostProcessor的后置处理方法）
7、生成完整的bean对象，通过getBean方法可以直接获取
8、销毁过程

二、谈一下Spring IOC的底层实现
1、先通过createBeanFactory创建出一个Bean工厂（DefaultListableBeanFactory）
2、开始循环创建对象，因为容器中的bean默认都是单例的，所以优先通过getBean，doGetBean从容器中查找
3、找不到的话，通过createBean，doCreateBean方法，以反射的方式创建对象，一般情况下使用的是无参构造方法（getDeclaredConstructor，newInstance）
4、进行对象填充populateBean
5、进行其他的初始化操作（InitializingBean）

三、描述一下bean的生命周期
背图：【https://juejin.cn/post/6844904065457979405】
在表述的时候不要只说图中的关键点，要学会扩展
1、实例化bean，反射的方式生成对象
2、填充bean的属性：populateBean()，循环依赖问题（三级缓存）
3、调用aware接口的相关方法：invokeAwareMethod（完成BeanName，BeanFactory，BeanClassLoader对象的属性设置）
4、调用BeanPostProcessor中的前置处理方法：使用比较多的有（ApplicationContextPostProcessor，设置ApplicationContext，Enviroonment，ResourceLoader，EmbeddedValueResolver等对象）
5、调用initmethod方法：invokeinitmethod()，判断是否实现了InitializingBean，如果有，调用afterPropertiesSet方法，没有就不会调用
6、调用BeanPostProcessor的后置处理方法：Spring的aop就是在此处实现的，AbstractAutoProxyCreator
7、注册destruction相关的回调接口
8、获取到完整的对象，可以通过getBean的方式来进行对象的获取
9、销毁路程：（1）是否实现了DisposableBean接口 （2）调用destroyMethod方法
【博客】https://blog.csdn.net/FBB360JAVA/article/details/125547477?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-9-125547477-blog-126193536.pc_relevant_recovery_v2&spm=1001.2101.3001.4242.6&utm_relevant_index=12

四、Spring是如何解决循环依赖的问题的
三级缓存，提前暴露对象，aop
总：
什么是循环依赖问题，A-》B-》A
分：
1、形成闭环的原因
先说明bean的创建过程：（1）实例化 （2）初始化（填充属性）
1、先创建A对象，实例化A对象，此时A对象中的b属性为空
2、容器中查找B对象，如果找到了，直接赋值结束，找不到则创建B对象
3、实例化B对象，此时B对象的a属性为空，填充属性a
4、从容器中查找A对象，找不到，直接创建
2、解决方案：
（1）将实例化和初始化的过程分开，这样就有了一级缓存和二级缓存，一级缓存存完整对象，二级缓存存未初始化对象，同名对象不会在一级和二级同时存在，先查询一级缓存再查询二级缓存。
（2）为什么需要三级缓存？三级缓存的value类型是ObjectFactory是一个函数式接口，存在的意义就是保证整个容器的运行过程中不存在同名的bean。
（3）如果一个对象需要被代理，或是说需要生成代理对象，那么要不要优先生成一个普通对象？答案：要
普通对象和代理对象是不能同时出现在容器中的，因此当一个对象需要呗代理的时候，就需要用代理对象覆盖掉普通对象，但是在实际的调用过程中，是没有办法确定什么时候对象会被使用，所以就要求某个对象呗调用的时候，优先判断此对象是否需要呗代理，因此传入lambda表达式的时候，可以通过表达式来执行对象的覆盖过程，getEarlyBeanReference()
  因此，所有的bean对象在创建的时候都要优先放到三级缓存中，在后续的使用过程中，如果需要被代理则返回代理对象，如果不需要被代理，则直接返回普通对象
【博客】https://zhuanlan.zhihu.com/p/157314153

【缓存的存放时间和删除时间】
1、三级缓存（addSingletonFactory）：createBeaninstance会后
2、二级缓存（getSingleton）：第一次从三级缓存确定对象是代理对象还是普通对象，同时删除三级缓存
3、一级缓存（addSingleton）：生成完整对象后放到一级缓存，删除二三级缓存

五、Bean Factory与FactoryBean有什么区别

六、Spring中用到的设计模式

七、Spring的AOP的底层实现原理

八、Srping的事务是如何回滚的

九、谈一下Spring事务传播
